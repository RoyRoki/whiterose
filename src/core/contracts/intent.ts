import { CodebaseUnderstanding, BehavioralContract, FeatureIntent } from '../../types.js';

export function generateIntentDocument(understanding: CodebaseUnderstanding): string {
  const lines: string[] = [];

  // Header
  lines.push(`# App Intent: ${understanding.summary.type}`);
  lines.push('');
  lines.push(`> Generated by whiterose on ${new Date().toISOString()}`);
  lines.push('> Edit the sections above the line. Contracts below are auto-generated.');
  lines.push('');

  // Overview
  lines.push('## Overview');
  lines.push('');
  lines.push(understanding.summary.description);
  lines.push('');
  lines.push(`- **Framework:** ${understanding.summary.framework || 'None detected'}`);
  lines.push(`- **Language:** ${understanding.summary.language}`);
  lines.push(`- **Files:** ${understanding.structure.totalFiles}`);
  if (understanding.structure.packages?.length) {
    lines.push(`- **Packages:** ${understanding.structure.packages.join(', ')}`);
  }
  lines.push('');

  // Critical Features
  if (understanding.features.length > 0) {
    lines.push('## Critical Features');
    lines.push('');

    const criticalFeatures = understanding.features.filter((f) => f.priority === 'critical');
    const highFeatures = understanding.features.filter((f) => f.priority === 'high');
    const otherFeatures = understanding.features.filter(
      (f) => f.priority !== 'critical' && f.priority !== 'high'
    );

    for (const feature of criticalFeatures) {
      lines.push(formatFeature(feature, 'CRITICAL'));
    }

    if (highFeatures.length > 0) {
      lines.push('## High Priority Features');
      lines.push('');
      for (const feature of highFeatures) {
        lines.push(formatFeature(feature, 'HIGH'));
      }
    }

    if (otherFeatures.length > 0) {
      lines.push('## Other Features');
      lines.push('');
      for (const feature of otherFeatures) {
        lines.push(formatFeature(feature));
      }
    }
  }

  // Known Constraints (editable section)
  lines.push('## Known Constraints');
  lines.push('');
  lines.push('<!-- Add any known constraints or business rules here -->');
  lines.push('');
  lines.push('- (Add your constraints here)');
  lines.push('');

  // Areas of Concern (editable section)
  lines.push('## Areas of Concern');
  lines.push('');
  lines.push('<!-- Add files or areas that need extra scrutiny -->');
  lines.push('');
  lines.push('- (Add files that have had bugs before)');
  lines.push('');

  // Divider
  lines.push('---');
  lines.push('');
  lines.push('<!-- âš ï¸ DO NOT EDIT BELOW THIS LINE - Auto-generated contracts -->');
  lines.push('');

  // Behavioral Contracts
  if (understanding.contracts.length > 0) {
    lines.push('## Behavioral Contracts');
    lines.push('');

    for (const contract of understanding.contracts) {
      lines.push(formatContract(contract));
    }
  }

  return lines.join('\n');
}

function formatFeature(feature: FeatureIntent, badge?: string): string {
  const lines: string[] = [];

  const badgeStr = badge ? ` [${badge}]` : '';
  lines.push(`### ${feature.name}${badgeStr}`);
  lines.push('');
  lines.push(feature.description);
  lines.push('');

  if (feature.constraints.length > 0) {
    lines.push('**Constraints:**');
    for (const constraint of feature.constraints) {
      lines.push(`- ${constraint}`);
    }
    lines.push('');
  }

  if (feature.relatedFiles.length > 0) {
    lines.push(`**Files:** \`${feature.relatedFiles.join('`, `')}\``);
    lines.push('');
  }

  return lines.join('\n');
}

function formatContract(contract: BehavioralContract): string {
  const lines: string[] = [];

  lines.push(`### \`${contract.file}:${contract.function}()\``);
  lines.push('');

  // Inputs
  if (contract.inputs.length > 0) {
    lines.push('**Inputs:**');
    for (const input of contract.inputs) {
      const constraints = input.constraints ? ` (${input.constraints})` : '';
      lines.push(`- \`${input.name}\`: ${input.type}${constraints}`);
    }
    lines.push('');
  }

  // Outputs
  lines.push('**Returns:** `' + contract.outputs.type + '`');
  if (contract.outputs.constraints) {
    lines.push(`  - ${contract.outputs.constraints}`);
  }
  lines.push('');

  // Invariants
  if (contract.invariants.length > 0) {
    lines.push('**Invariants:**');
    for (const invariant of contract.invariants) {
      lines.push(`- ${invariant}`);
    }
    lines.push('');
  }

  // Side Effects
  if (contract.sideEffects.length > 0) {
    lines.push('**Side Effects:**');
    for (const effect of contract.sideEffects) {
      lines.push(`- ${effect}`);
    }
    lines.push('');
  }

  // Throws
  if (contract.throws && contract.throws.length > 0) {
    lines.push('**Throws:**');
    for (const t of contract.throws) {
      lines.push(`- ${t}`);
    }
    lines.push('');
  }

  return lines.join('\n');
}

interface ParsedIntent {
  knownConstraints: string[];
  areasOfConcern: string[];
  customFeatures: FeatureIntent[];
  overrides: {
    description?: string;
    framework?: string;
  };
}

export function parseIntentDocument(content: string): ParsedIntent {
  const result: ParsedIntent = {
    knownConstraints: [],
    areasOfConcern: [],
    customFeatures: [],
    overrides: {},
  };

  // Split into sections
  const sections = splitIntoSections(content);

  // Parse Known Constraints section
  const constraintsSection = sections.find((s) => s.title.includes('Known Constraints'));
  if (constraintsSection) {
    result.knownConstraints = parseListItems(constraintsSection.content);
  }

  // Parse Areas of Concern section
  const concernsSection = sections.find((s) => s.title.includes('Areas of Concern'));
  if (concernsSection) {
    result.areasOfConcern = parseListItems(concernsSection.content);
  }

  // Parse Overview for overrides
  const overviewSection = sections.find((s) => s.title.includes('Overview'));
  if (overviewSection) {
    // Check for framework override
    const frameworkMatch = overviewSection.content.match(/\*\*Framework:\*\*\s*(.+)/);
    if (frameworkMatch && !frameworkMatch[1].includes('None detected')) {
      result.overrides.framework = frameworkMatch[1].trim();
    }

    // Get first paragraph as description override
    const paragraphs = overviewSection.content.split(/\n\n+/);
    const firstParagraph = paragraphs[0]?.trim();
    if (firstParagraph && !firstParagraph.startsWith('-') && !firstParagraph.startsWith('*')) {
      result.overrides.description = firstParagraph;
    }
  }

  // Parse custom features (those added by user above the divider)
  const editableSections = content.split(/---+/)[0] || '';
  const featureSections = editableSections.match(/###\s+([^\n]+)\n([\s\S]*?)(?=###|##|$)/g);

  if (featureSections) {
    for (const section of featureSections) {
      const feature = parseFeatureSection(section);
      if (feature && isUserAddedFeature(feature)) {
        result.customFeatures.push(feature);
      }
    }
  }

  return result;
}

interface Section {
  title: string;
  content: string;
}

function splitIntoSections(content: string): Section[] {
  const sections: Section[] = [];
  const sectionRegex = /^##\s+([^\n]+)\n([\s\S]*?)(?=^##\s|$)/gm;

  let match;
  while ((match = sectionRegex.exec(content)) !== null) {
    sections.push({
      title: match[1].trim(),
      content: match[2].trim(),
    });
  }

  return sections;
}

function parseListItems(content: string): string[] {
  const items: string[] = [];
  const lines = content.split('\n');

  for (const line of lines) {
    const match = line.match(/^[-*]\s+(.+)/);
    if (match) {
      const item = match[1].trim();
      // Skip placeholder items
      if (!item.includes('Add your') && !item.includes('Add files') && item !== '') {
        items.push(item);
      }
    }
  }

  return items;
}

function parseFeatureSection(section: string): FeatureIntent | null {
  const titleMatch = section.match(/###\s+([^[\n]+)(?:\s*\[([^\]]+)\])?/);
  if (!titleMatch) return null;

  const name = titleMatch[1].trim();
  const badge = titleMatch[2]?.trim().toLowerCase();

  // Get priority from badge
  let priority: 'critical' | 'high' | 'medium' | 'low' = 'medium';
  if (badge === 'critical') priority = 'critical';
  else if (badge === 'high') priority = 'high';
  else if (badge === 'low') priority = 'low';

  // Get description (first paragraph after title)
  const contentAfterTitle = section.replace(/###\s+[^\n]+\n/, '').trim();
  const paragraphs = contentAfterTitle.split(/\n\n+/);
  const description = paragraphs[0]?.trim() || '';

  // Get constraints
  const constraints: string[] = [];
  const constraintsMatch = section.match(/\*\*Constraints:\*\*\n((?:[-*]\s+[^\n]+\n?)+)/);
  if (constraintsMatch) {
    const constraintLines = constraintsMatch[1].split('\n');
    for (const line of constraintLines) {
      const match = line.match(/^[-*]\s+(.+)/);
      if (match) {
        constraints.push(match[1].trim());
      }
    }
  }

  // Get related files
  const relatedFiles: string[] = [];
  const filesMatch = section.match(/\*\*Files:\*\*\s*`([^`]+)`/);
  if (filesMatch) {
    const files = filesMatch[1].split(/`,\s*`/);
    relatedFiles.push(...files.map((f) => f.replace(/`/g, '').trim()));
  }

  return {
    name,
    description,
    priority,
    constraints,
    relatedFiles,
  };
}

function isUserAddedFeature(feature: FeatureIntent): boolean {
  // Check if this looks like a user-added feature
  // User-added features typically have more specific constraints or descriptions
  return (
    feature.constraints.length > 0 ||
    feature.description.length > 50 ||
    feature.relatedFiles.length > 0
  );
}

/**
 * Merge parsed intent with existing understanding
 */
export function mergeIntentWithUnderstanding(
  understanding: CodebaseUnderstanding,
  parsedIntent: ParsedIntent
): CodebaseUnderstanding {
  const merged = { ...understanding };

  // Apply overrides
  if (parsedIntent.overrides.description) {
    merged.summary = {
      ...merged.summary,
      description: parsedIntent.overrides.description,
    };
  }

  if (parsedIntent.overrides.framework) {
    merged.summary = {
      ...merged.summary,
      framework: parsedIntent.overrides.framework,
    };
  }

  // Add custom features
  if (parsedIntent.customFeatures.length > 0) {
    merged.features = [
      ...parsedIntent.customFeatures,
      ...merged.features.filter(
        (f) => !parsedIntent.customFeatures.some((cf) => cf.name === f.name)
      ),
    ];
  }

  // Add known constraints as invariants to relevant contracts
  if (parsedIntent.knownConstraints.length > 0) {
    // Add as global constraints (could be used for validation)
    (merged as any).globalConstraints = parsedIntent.knownConstraints;
  }

  // Store areas of concern for priority scanning
  if (parsedIntent.areasOfConcern.length > 0) {
    (merged as any).areasOfConcern = parsedIntent.areasOfConcern;
  }

  return merged;
}
